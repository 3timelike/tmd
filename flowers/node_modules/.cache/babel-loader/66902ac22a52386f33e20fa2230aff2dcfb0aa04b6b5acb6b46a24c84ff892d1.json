{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar vue = require('vue');\nvar lodashUnified = require('lodash-unified');\nrequire('../../../constants/index.js');\nrequire('../../../hooks/index.js');\nrequire('../../../utils/index.js');\nvar utils = require('./utils.js');\nvar tokens = require('./tokens.js');\nvar pluginVue_exportHelper = require('../../../_virtual/plugin-vue_export-helper.js');\nvar index = require('../../../hooks/use-escape-keydown/index.js');\nvar aria = require('../../../constants/aria.js');\nvar shared = require('@vue/shared');\nconst _sfc_main = vue.defineComponent({\n  name: \"ElFocusTrap\",\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object,\n    focusStartEl: {\n      type: [Object, String],\n      default: \"first\"\n    }\n  },\n  emits: [tokens.ON_TRAP_FOCUS_EVT, tokens.ON_RELEASE_FOCUS_EVT, \"focusin\", \"focusout\", \"focusout-prevented\", \"release-requested\"],\n  setup(props, {\n    emit\n  }) {\n    const forwardRef = vue.ref();\n    let lastFocusBeforeTrapped;\n    let lastFocusAfterTrapped;\n    const {\n      focusReason\n    } = utils.useFocusReason();\n    index.useEscapeKeydown(event => {\n      if (props.trapped && !focusLayer.paused) {\n        emit(\"release-requested\", event);\n      }\n    });\n    const focusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true;\n      },\n      resume() {\n        this.paused = false;\n      }\n    };\n    const onKeydown = e => {\n      if (!props.loop && !props.trapped) return;\n      if (focusLayer.paused) return;\n      const {\n        key,\n        altKey,\n        ctrlKey,\n        metaKey,\n        currentTarget,\n        shiftKey\n      } = e;\n      const {\n        loop\n      } = props;\n      const isTabbing = key === aria.EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;\n      const currentFocusingEl = document.activeElement;\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget;\n        const [first, last] = utils.getEdges(container);\n        const isTabbable = first && last;\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            const focusoutPreventedEvent = utils.createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n            }\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            const focusoutPreventedEvent = utils.createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n              if (loop) utils.tryFocus(first, true);\n            }\n          } else if (shiftKey && [first, container].includes(currentFocusingEl)) {\n            const focusoutPreventedEvent = utils.createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n              if (loop) utils.tryFocus(last, true);\n            }\n          }\n        }\n      }\n    };\n    vue.provide(tokens.FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown\n    });\n    vue.watch(() => props.focusTrapEl, focusTrapEl => {\n      if (focusTrapEl) {\n        forwardRef.value = focusTrapEl;\n      }\n    }, {\n      immediate: true\n    });\n    vue.watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {\n      if (forwardRef2) {\n        forwardRef2.addEventListener(\"keydown\", onKeydown);\n        forwardRef2.addEventListener(\"focusin\", onFocusIn);\n        forwardRef2.addEventListener(\"focusout\", onFocusOut);\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener(\"keydown\", onKeydown);\n        oldForwardRef.removeEventListener(\"focusin\", onFocusIn);\n        oldForwardRef.removeEventListener(\"focusout\", onFocusOut);\n      }\n    });\n    const trapOnFocus = e => {\n      emit(tokens.ON_TRAP_FOCUS_EVT, e);\n    };\n    const releaseOnFocus = e => emit(tokens.ON_RELEASE_FOCUS_EVT, e);\n    const onFocusIn = e => {\n      const trapContainer = vue.unref(forwardRef);\n      if (!trapContainer) return;\n      const target = e.target;\n      const relatedTarget = e.relatedTarget;\n      const isFocusedInTrap = target && trapContainer.contains(target);\n      if (!props.trapped) {\n        const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);\n        if (!isPrevFocusedInTrap) {\n          lastFocusBeforeTrapped = relatedTarget;\n        }\n      }\n      if (isFocusedInTrap) emit(\"focusin\", e);\n      if (focusLayer.paused) return;\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target;\n        } else {\n          utils.tryFocus(lastFocusAfterTrapped, true);\n        }\n      }\n    };\n    const onFocusOut = e => {\n      const trapContainer = vue.unref(forwardRef);\n      if (focusLayer.paused || !trapContainer) return;\n      if (props.trapped) {\n        const relatedTarget = e.relatedTarget;\n        if (!lodashUnified.isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          setTimeout(() => {\n            if (!focusLayer.paused && props.trapped) {\n              const focusoutPreventedEvent = utils.createFocusOutPreventedEvent({\n                focusReason: focusReason.value\n              });\n              emit(\"focusout-prevented\", focusoutPreventedEvent);\n              if (!focusoutPreventedEvent.defaultPrevented) {\n                utils.tryFocus(lastFocusAfterTrapped, true);\n              }\n            }\n          }, 0);\n        }\n      } else {\n        const target = e.target;\n        const isFocusedInTrap = target && trapContainer.contains(target);\n        if (!isFocusedInTrap) emit(\"focusout\", e);\n      }\n    };\n    async function startTrap() {\n      await vue.nextTick();\n      const trapContainer = vue.unref(forwardRef);\n      if (trapContainer) {\n        utils.focusableStack.push(focusLayer);\n        const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;\n        lastFocusBeforeTrapped = prevFocusedElement;\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement);\n        if (!isPrevFocusContained) {\n          const focusEvent = new Event(tokens.FOCUS_AFTER_TRAPPED, tokens.FOCUS_AFTER_TRAPPED_OPTS);\n          trapContainer.addEventListener(tokens.FOCUS_AFTER_TRAPPED, trapOnFocus);\n          trapContainer.dispatchEvent(focusEvent);\n          if (!focusEvent.defaultPrevented) {\n            vue.nextTick(() => {\n              let focusStartEl = props.focusStartEl;\n              if (!shared.isString(focusStartEl)) {\n                utils.tryFocus(focusStartEl);\n                if (document.activeElement !== focusStartEl) {\n                  focusStartEl = \"first\";\n                }\n              }\n              if (focusStartEl === \"first\") {\n                utils.focusFirstDescendant(utils.obtainAllFocusableElements(trapContainer), true);\n              }\n              if (document.activeElement === prevFocusedElement || focusStartEl === \"container\") {\n                utils.tryFocus(trapContainer);\n              }\n            });\n          }\n        }\n      }\n    }\n    function stopTrap() {\n      const trapContainer = vue.unref(forwardRef);\n      if (trapContainer) {\n        trapContainer.removeEventListener(tokens.FOCUS_AFTER_TRAPPED, trapOnFocus);\n        const releasedEvent = new CustomEvent(tokens.FOCUS_AFTER_RELEASED, {\n          ...tokens.FOCUS_AFTER_TRAPPED_OPTS,\n          detail: {\n            focusReason: focusReason.value\n          }\n        });\n        trapContainer.addEventListener(tokens.FOCUS_AFTER_RELEASED, releaseOnFocus);\n        trapContainer.dispatchEvent(releasedEvent);\n        if (!releasedEvent.defaultPrevented && (focusReason.value == \"keyboard\" || !utils.isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {\n          utils.tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);\n        }\n        trapContainer.removeEventListener(tokens.FOCUS_AFTER_RELEASED, releaseOnFocus);\n        utils.focusableStack.remove(focusLayer);\n      }\n    }\n    vue.onMounted(() => {\n      if (props.trapped) {\n        startTrap();\n      }\n      vue.watch(() => props.trapped, trapped => {\n        if (trapped) {\n          startTrap();\n        } else {\n          stopTrap();\n        }\n      });\n    });\n    vue.onBeforeUnmount(() => {\n      if (props.trapped) {\n        stopTrap();\n      }\n    });\n    return {\n      onKeydown\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return vue.renderSlot(_ctx.$slots, \"default\", {\n    handleKeydown: _ctx.onKeydown\n  });\n}\nvar ElFocusTrap = /* @__PURE__ */pluginVue_exportHelper[\"default\"](_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"focus-trap.vue\"]]);\nexports[\"default\"] = ElFocusTrap;","map":{"version":3,"names":["_sfc_main","vue","defineComponent","name","inheritAttrs","props","loop","Boolean","trapped","focusTrapEl","Object","focusStartEl","type","String","default","emits","tokens","ON_TRAP_FOCUS_EVT","ON_RELEASE_FOCUS_EVT","setup","emit","forwardRef","ref","lastFocusBeforeTrapped","lastFocusAfterTrapped","focusReason","utils","useFocusReason","index","useEscapeKeydown","event","focusLayer","paused","pause","resume","onKeydown","e","key","altKey","ctrlKey","metaKey","currentTarget","shiftKey","isTabbing","aria","EVENT_CODE","tab","currentFocusingEl","document","activeElement","container","first","last","getEdges","isTabbable","focusoutPreventedEvent","createFocusOutPreventedEvent","value","defaultPrevented","preventDefault","tryFocus","includes","provide","FOCUS_TRAP_INJECTION_KEY","focusTrapRef","watch","immediate","forwardRef2","oldForwardRef","addEventListener","onFocusIn","onFocusOut","removeEventListener","trapOnFocus","releaseOnFocus","trapContainer","unref","target","relatedTarget","isFocusedInTrap","contains","isPrevFocusedInTrap","lodashUnified","isNil","setTimeout","startTrap","nextTick","focusableStack","push","prevFocusedElement","isPrevFocusContained","focusEvent","Event","FOCUS_AFTER_TRAPPED","FOCUS_AFTER_TRAPPED_OPTS","dispatchEvent","shared","isString","focusFirstDescendant","obtainAllFocusableElements","stopTrap","releasedEvent","CustomEvent","FOCUS_AFTER_RELEASED","detail","isFocusCausedByUserEvent","body","remove","onMounted","onBeforeUnmount","renderSlot","_ctx","$slots","handleKeydown"],"sources":["../../../../../../packages/components/focus-trap/src/focus-trap.vue"],"sourcesContent":["<template>\n  <slot :handle-keydown=\"onKeydown\" />\n</template>\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  ref,\n  unref,\n  watch,\n} from 'vue'\nimport { isNil } from 'lodash-unified'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { useEscapeKeydown } from '@element-plus/hooks'\nimport { isString } from '@element-plus/utils'\nimport {\n  createFocusOutPreventedEvent,\n  focusFirstDescendant,\n  focusableStack,\n  getEdges,\n  isFocusCausedByUserEvent,\n  obtainAllFocusableElements,\n  tryFocus,\n  useFocusReason,\n} from './utils'\nimport {\n  FOCUS_AFTER_RELEASED,\n  FOCUS_AFTER_TRAPPED,\n  FOCUS_AFTER_TRAPPED_OPTS,\n  FOCUS_TRAP_INJECTION_KEY,\n  ON_RELEASE_FOCUS_EVT,\n  ON_TRAP_FOCUS_EVT,\n} from './tokens'\n\nimport type { PropType } from 'vue'\nimport type { FocusLayer } from './utils'\n\nexport default defineComponent({\n  name: 'ElFocusTrap',\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object as PropType<HTMLElement>,\n    focusStartEl: {\n      type: [Object, String] as PropType<'container' | 'first' | HTMLElement>,\n      default: 'first',\n    },\n  },\n  emits: [\n    ON_TRAP_FOCUS_EVT,\n    ON_RELEASE_FOCUS_EVT,\n    'focusin',\n    'focusout',\n    'focusout-prevented',\n    'release-requested',\n  ],\n  setup(props, { emit }) {\n    const forwardRef = ref<HTMLElement | undefined>()\n    let lastFocusBeforeTrapped: HTMLElement | null\n    let lastFocusAfterTrapped: HTMLElement | null\n\n    const { focusReason } = useFocusReason()\n\n    useEscapeKeydown((event) => {\n      if (props.trapped && !focusLayer.paused) {\n        emit('release-requested', event)\n      }\n    })\n\n    const focusLayer: FocusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true\n      },\n      resume() {\n        this.paused = false\n      },\n    }\n\n    const onKeydown = (e: KeyboardEvent) => {\n      if (!props.loop && !props.trapped) return\n      if (focusLayer.paused) return\n\n      const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e\n      const { loop } = props\n      const isTabbing =\n        key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey\n\n      const currentFocusingEl = document.activeElement\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget as HTMLElement\n        const [first, last] = getEdges(container)\n        const isTabbable = first && last\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value,\n            })\n            emit('focusout-prevented', focusoutPreventedEvent)\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault()\n            }\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value,\n            })\n            emit('focusout-prevented', focusoutPreventedEvent)\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault()\n              if (loop) tryFocus(first, true)\n            }\n          } else if (\n            shiftKey &&\n            [first, container].includes(currentFocusingEl as HTMLElement)\n          ) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value,\n            })\n            emit('focusout-prevented', focusoutPreventedEvent)\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault()\n              if (loop) tryFocus(last, true)\n            }\n          }\n        }\n      }\n    }\n\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown,\n    })\n\n    watch(\n      () => props.focusTrapEl,\n      (focusTrapEl) => {\n        if (focusTrapEl) {\n          forwardRef.value = focusTrapEl\n        }\n      },\n      { immediate: true }\n    )\n\n    watch([forwardRef], ([forwardRef], [oldForwardRef]) => {\n      if (forwardRef) {\n        forwardRef.addEventListener('keydown', onKeydown)\n        forwardRef.addEventListener('focusin', onFocusIn)\n        forwardRef.addEventListener('focusout', onFocusOut)\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener('keydown', onKeydown)\n        oldForwardRef.removeEventListener('focusin', onFocusIn)\n        oldForwardRef.removeEventListener('focusout', onFocusOut)\n      }\n    })\n\n    const trapOnFocus = (e: Event) => {\n      emit(ON_TRAP_FOCUS_EVT, e)\n    }\n    const releaseOnFocus = (e: Event) => emit(ON_RELEASE_FOCUS_EVT, e)\n\n    const onFocusIn = (e: FocusEvent) => {\n      const trapContainer = unref(forwardRef)\n      if (!trapContainer) return\n\n      const target = e.target as HTMLElement | null\n      const relatedTarget = e.relatedTarget as HTMLElement | null\n      const isFocusedInTrap = target && trapContainer.contains(target)\n\n      if (!props.trapped) {\n        const isPrevFocusedInTrap =\n          relatedTarget && trapContainer.contains(relatedTarget)\n        if (!isPrevFocusedInTrap) {\n          lastFocusBeforeTrapped = relatedTarget\n        }\n      }\n\n      if (isFocusedInTrap) emit('focusin', e)\n\n      if (focusLayer.paused) return\n\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target\n        } else {\n          tryFocus(lastFocusAfterTrapped, true)\n        }\n      }\n    }\n\n    const onFocusOut = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (focusLayer.paused || !trapContainer) return\n\n      if (props.trapped) {\n        const relatedTarget = (e as FocusEvent)\n          .relatedTarget as HTMLElement | null\n        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          // Give embedded focus layer time to pause this layer before reclaiming focus\n          // And only reclaim focus if it should currently be trapping\n          setTimeout(() => {\n            if (!focusLayer.paused && props.trapped) {\n              const focusoutPreventedEvent = createFocusOutPreventedEvent({\n                focusReason: focusReason.value,\n              })\n              emit('focusout-prevented', focusoutPreventedEvent)\n              if (!focusoutPreventedEvent.defaultPrevented) {\n                tryFocus(lastFocusAfterTrapped, true)\n              }\n            }\n          }, 0)\n        }\n      } else {\n        const target = e.target as HTMLElement | null\n        const isFocusedInTrap = target && trapContainer.contains(target)\n        if (!isFocusedInTrap) emit('focusout', e)\n      }\n    }\n\n    async function startTrap() {\n      // Wait for forwardRef to resolve\n      await nextTick()\n      const trapContainer = unref(forwardRef)\n      if (trapContainer) {\n        focusableStack.push(focusLayer)\n        const prevFocusedElement = trapContainer.contains(\n          document.activeElement\n        )\n          ? lastFocusBeforeTrapped\n          : document.activeElement\n        lastFocusBeforeTrapped = prevFocusedElement as HTMLElement | null\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement)\n        if (!isPrevFocusContained) {\n          const focusEvent = new Event(\n            FOCUS_AFTER_TRAPPED,\n            FOCUS_AFTER_TRAPPED_OPTS\n          )\n          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n          trapContainer.dispatchEvent(focusEvent)\n          if (!focusEvent.defaultPrevented) {\n            nextTick(() => {\n              let focusStartEl = props.focusStartEl\n              if (!isString(focusStartEl)) {\n                tryFocus(focusStartEl)\n                if (document.activeElement !== focusStartEl) {\n                  focusStartEl = 'first'\n                }\n              }\n              if (focusStartEl === 'first') {\n                focusFirstDescendant(\n                  obtainAllFocusableElements(trapContainer),\n                  true\n                )\n              }\n              if (\n                document.activeElement === prevFocusedElement ||\n                focusStartEl === 'container'\n              ) {\n                tryFocus(trapContainer)\n              }\n            })\n          }\n        }\n      }\n    }\n\n    function stopTrap() {\n      const trapContainer = unref(forwardRef)\n\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n\n        const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {\n          ...FOCUS_AFTER_TRAPPED_OPTS,\n          detail: {\n            focusReason: focusReason.value,\n          },\n        })\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus)\n        trapContainer.dispatchEvent(releasedEvent)\n        if (\n          !releasedEvent.defaultPrevented &&\n          (focusReason.value == 'keyboard' ||\n            !isFocusCausedByUserEvent() ||\n            trapContainer.contains(document.activeElement))\n        ) {\n          tryFocus(lastFocusBeforeTrapped ?? document.body)\n        }\n\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus)\n        focusableStack.remove(focusLayer)\n      }\n    }\n\n    onMounted(() => {\n      if (props.trapped) {\n        startTrap()\n      }\n\n      watch(\n        () => props.trapped,\n        (trapped) => {\n          if (trapped) {\n            startTrap()\n          } else {\n            stopTrap()\n          }\n        }\n      )\n    })\n\n    onBeforeUnmount(() => {\n      if (props.trapped) {\n        stopTrap()\n      }\n    })\n\n    return {\n      onKeydown,\n    }\n  },\n})\n</script>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}